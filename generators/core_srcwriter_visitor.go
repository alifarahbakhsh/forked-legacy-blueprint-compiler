package generators

import (
	"log"
	"os"
	"path"
	"strings"

	"gitlab.mpi-sws.org/cld/blueprint/blueprint-compiler/parser"
)

type SourceCodeWriterVisitor struct {
	DefaultVisitor
	logger      *log.Logger
	curDir      string
	appName     string
	pkgName     string
	specDir     string
	remoteTypes map[string]*parser.ImplInfo
	services    map[string]*parser.ServiceInfo
	pathpkgs    map[string]string
}

func NewSourceCodeWriterVisitor(logger *log.Logger, outDir string, appName string, specDir string, remoteTypes map[string]*parser.ImplInfo, services map[string]*parser.ServiceInfo, pkgs map[string]string) *SourceCodeWriterVisitor {
	return &SourceCodeWriterVisitor{logger: logger, curDir: outDir, appName: appName, pkgName: "", specDir: specDir, remoteTypes: remoteTypes, services: services, pathpkgs: pkgs}
}

func (v *SourceCodeWriterVisitor) VisitMillenialNode(_ Visitor, n *MillenialNode) {
	v.logger.Println("Starting SourceCodeWriter visit")
	v.DefaultVisitor.VisitMillenialNode(v, n)
	v.logger.Println("Ending SourceCodeWriter visit")
}

func (v *SourceCodeWriterVisitor) VisitDockerContainerNode(_ Visitor, n *DockerContainerNode) {
	oldPath := v.curDir
	new_dir := path.Join(oldPath, strings.ToLower(n.Name))
	v.curDir = new_dir
	v.DefaultVisitor.VisitDockerContainerNode(v, n)
	v.curDir = oldPath
}

func (v *SourceCodeWriterVisitor) VisitProcessNode(_ Visitor, n *ProcessNode) {
	oldPath := v.curDir
	new_dir := path.Join(oldPath, strings.ToLower(n.Name))
	err := os.MkdirAll(new_dir, 0755)
	if err != nil {
		v.logger.Fatal(err)
	}
	v.curDir = new_dir
	v.pkgName = strings.ToLower(n.Name)
	v.DefaultVisitor.VisitProcessNode(v, n)
	v.pkgName = ""
	v.curDir = oldPath
}

func (v *SourceCodeWriterVisitor) WriteFile(info *ServiceImplInfo) {
	go_file := path.Join(v.curDir, info.Name+".go")
	outf, err := os.OpenFile(go_file, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		v.logger.Fatal(err)
	}
	defer outf.Close()
	_, err = outf.WriteString("// Blueprint: auto-generated by " + info.PluginName + " plugin\n")
	if err != nil {
		v.logger.Fatal(err)
	}
	_, err = outf.WriteString("package " + v.pkgName + "\n\n")
	if err != nil {
		v.logger.Fatal(err)
	}
	// Write imports
	var import_string string
	written_imports := make(map[string]bool)
	import_string = "import (\n"
	for _, importInfo := range info.Imports {
		import_string += "\t"
		if importInfo.ImportName != "" {
			import_string += importInfo.ImportName + " "
		}
		import_string += "\"" + importInfo.FullName + "\"" + "\n"
		written_imports[importInfo.FullName] = true
	}
	for _, importInfo := range info.BaseImports {
		if _, ok := written_imports[importInfo.FullName]; ok {
			continue
		}
		import_string += "\t"
		if importInfo.ImportName != "" {
			import_string += importInfo.ImportName + " "
		}
		import_string += "\"" + importInfo.FullName + "\"\n"
	}
	import_string += ")\n\n"
	_, err = outf.WriteString(import_string)
	if err != nil {
		v.logger.Fatal(err)
	}

	// Write Type
	if len(info.Fields) > 0 {
		var type_string string
		type_string += "type " + info.Name + " struct {\n"
		for _, field := range info.Fields {
			type_string += "\t" + field.String() + "\n"
		}
		type_string += "}\n"
		_, err = outf.WriteString(type_string)
		if err != nil {
			v.logger.Fatal(err)
		}
	}

	// Write Dependent structs
	if len(info.Structs) > 0 {
		struct_string := ""
		for _, sinfo := range info.Structs {
			struct_string += "type " + sinfo.Name + " struct {\n"
			v.logger.Println(sinfo.Fields)
			for _, field := range sinfo.Fields {
				struct_string += "\t" + field.String() + "\n"
			}
			struct_string += "}\n"
		}
		_, err = outf.WriteString(struct_string)
		if err != nil {
			v.logger.Fatal(err)
		}
	}

	// Write Constructor
	for _, constructor := range info.Constructors {
		name := constructor.Name
		body := info.MethodBodies[constructor.Name]
		var arg_strings []string
		for _, arg := range constructor.Args {
			arg_strings = append(arg_strings, arg.String())
		}
		var ret_strings []string
		for _, retarg := range constructor.Return {
			ret_strings = append(ret_strings, retarg.String())
		}
		func_string := "func " + name + "(" + strings.Join(arg_strings, ",") + ") "
		if len(ret_strings) > 1 {
			func_string += "(" + strings.Join(ret_strings, ", ") + ")"
		} else {
			func_string += strings.Join(ret_strings, ", ")
		}
		func_string += " {\n"
		func_string += "\t" + strings.ReplaceAll(body, "\n", "\n\t")
		func_string += "\n}\n"
		_, err := outf.WriteString(func_string + "\n")
		if err != nil {
			v.logger.Fatal(err)
		}
	}

	// Write function informations
	for name, method := range info.Methods {
		body := info.MethodBodies[name]
		var arg_strings []string
		for _, arg := range method.Args {
			arg_strings = append(arg_strings, arg.String())
		}
		var ret_strings []string
		for _, retarg := range method.Return {
			ret_strings = append(ret_strings, retarg.String())
		}
		func_string := "func (" + info.ReceiverName + " *" + info.Name + ") " + name + "(" + strings.Join(arg_strings, ", ") + ") "
		if len(ret_strings) > 1 {
			func_string += "(" + strings.Join(ret_strings, ", ") + ")"
		} else {
			func_string += strings.Join(ret_strings, ", ")
		}
		func_string += " {\n"
		func_string += "\t" + strings.ReplaceAll(body, "\n", "\n\t")
		func_string += "\n}\n"
		_, err := outf.WriteString(func_string + "\n")
		if err != nil {
			v.logger.Fatal(err)
		}
	}
}

func (v *SourceCodeWriterVisitor) VisitFuncServiceNode(_ Visitor, n *FuncServiceNode) {
	v.logger.Println("Generating source code files for", n.ASTServerNodes[0].BaseName)
	for _, server_node := range n.ASTServerNodes {
		v.WriteFile(server_node)
	}

	// Write Client Nodes
	for _, param_nodes := range n.ParamClientNodes {
		for _, client_node := range param_nodes {
			v.WriteFile(client_node)
		}
	}

	// Write Modifier Instance Nodes
	for _, param_nodes := range n.ModifierClientNodes {
		for _, client_node := range param_nodes {
			v.WriteFile(client_node)
		}
	}
}

func (v *SourceCodeWriterVisitor) VisitQueueServiceNode(_ Visitor, n *QueueServiceNode) {
	v.logger.Println("Generating source code files for", n.Name)

	for _, param_nodes := range n.ParamClientNodes {
		for _, client_node := range param_nodes {
			v.WriteFile(client_node)
		}
	}

	for _, param_nodes := range n.ModifierClientNodes {
		for _, client_node := range param_nodes {
			v.WriteFile(client_node)
		}
	}
}
